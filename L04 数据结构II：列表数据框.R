#----------------------------------------------------
#四.列表
# 列表，可以包含不同类型的对象，甚至可以包括其他列表。列表的灵活性使得它非常有用
# 列表最大的好处就是，它能够将多个不同类型的对象打包到一起，使得可以根据位置和名字访问它们。
# 常用场景：将函数的多个返回值打包到一起作为一个对象返回。
#----------------------------------------------------


#----------------------------------------------------
## 1.创建列表 
#用list()将多个不同类型的对象创建为列表：
l0 <-  list(1,c(T,F),c("a","b","c"))

#在创建列表时，为列表的每个成分指定名字：
l1 <-  list(组件1=1,组件2=c(T,F),组件3=c("a","b","c"))
# $组件1
# [1] 1
# 
# $组件2
# [1]  TRUE FALSE
# 
# $组件3
# [1] "a" "b" "c"
l1 = list(A = 1, B = c(TRUE, FALSE), C = c("a", "b", "c"))

#创建列表后再对列表成分命名或修改名字：
names(l0)=NULL
names(l1)=c("x","y","z")
#----------------------------------------------------


#----------------------------------------------------
# 再来区分：[[ ]]与[ ]
# [[ ]]始终是提取一个元素的内容，列表某一个成分的内容（下一级元素）
# [ ]始终是提取子集，列表的子集是包含若干成分的子列表（仍是同类型对象）
## 2.从列表中提取成分的内容
#最常用的方法是用$，通过成分名字来提取该成分下的内容：
l1$x 
l1$d # 访问不存在的成分m, 将会返回NULL

#用[[n]]来提取列表第n个成分的内容，n也可以换成成分的名字：
l1[2] 
# $B
# [1]  TRUE FALSE
l1[[2]]  # 同l1[["y"]]
# [1]  TRUE FALSE

#注：用[[ ]]提取列表中某个成分的内容更加灵活，可用在函数调用中，通过参数来传递成分索引或名字：
p = "y"              #想要提取其内容的成分名字
l1[[p]]
l1[["y"]]
#----------------------------------------------------


#----------------------------------------------------
## 3.提取列表子集
# 用[]，可以取出列表中的一些成分，作为一个新的（子）列表。
# [] 中可以用字符向量表示成分名字，用数值向量表示成分位置，或用逻辑向量指定是否选择，来取出列表成分。
l1["x"] # 同l1[1]    $x [1] 1
l1[c("x","z")]
#----------------------------------------------------

#----------------------------------------------------
## 4.对列表的成分赋值
# 即先访问（提取）到列表的成分，再赋以相适应的值
l1$x=0

# 同时给多个列表成分赋值：
l1[c("x", "y")] = list(x = "new value for y", y = c(3, 1))

#移除列表中的某些成分，只需赋值为 NULL：
l1[c("z", "m")] = NULL
#----------------------------------------------------


#----------------------------------------------------
## 5. 列表函数
# as.list()将向量转换成列表：
l2 = as.list(c(a=1,b=2))
l2

# unlist()将一个列表打破成分界线，强制转换成一个向量^fn26：
unlist(l2)

# tidyverse系列中的purrr包为方便操作列表，提供了一系列操作列表的函数：
# 
# pluck()：同 [[ 提取列表中的元素
#             keep(): 保留满足条件的元素
#             discard(): 删除满足条件的元素
#             compact(): 删除列表中的空元素
#             append()：在列表末尾增加元素
#             flatten(): 摊平列表（只摊平一层）


#----------------------------------------------------
## 五.数据框
# 数据框是指有若干行和列的数据集，它与矩阵类似，但并不要求所有列都是相同的类型；
# 本质上讲，数据框就是一个列表，它的每个成分都是一个向量，并且长度相同，以表格的形式展现。总之，数据框是由列向量组成、有着矩阵形式的列表。

## 1.创建数据框
# 用tibble()根据若干列向量创建tibble:
library(tidyverse)
library(tibble)
persons <-  tibble(
  Name = c("Ken", "Ashley", "Jennifer"),
  Gender = c("Male", "Female", "Female"),
  Age = c(24, 25, 23),
  Major = c("Finance", "Statistics", "Computer Science")
)
persons
# tibble对比data.frame的优势：
# tibble()比 data.frame()做的更少：不改变输入变量的类型 (R 4.0.0 之前默认将字符串转化为因子！) ，不会改变变量名，不会创建行名；
# tibble对象的列名可以是R中的“非法名”：非字母开头、包含空格，但定义和使用变量时都需要用倒引号`括起来；
# tibble 在输出时不自动显示所有行，避免大数据框时显示很多内容；
# 用[]选取列子集时，即使只选取一列，返回结果仍是 tibble, 而不自动简化为向量。

# 用tribble()按行录入数据式创建tibble:
tribble(
  ~Name,~Gender,~Age,~Major,
  "Ken", "Male", 24, "Finance",
  "Ashley", "Female", 25, "Statistics",
  "Jennifer", "Female", 23, "Computer Science")

# 用as_tibble()将data.frame, matrix, 各成分等长度的list, 转换为 tibble。
# 对数据框的各列重命名：
df <- tibble(
  id=1:4,
  x=c(0,2,1,-1),
  y=c(0.5,0.2,0.1,0.5)
)
names(df) <- c("id","level","score")
df

# 2.提取数据框的元素、子集
df$level     # 同df[["x"]], df[[2]]
df[["level"]]
df[[2]][3]

# (1)用[]提取数据框的一列或多列，得到子数据框，其内可以是数值向量（列位置）、字符向量（列名）、逻辑向量（是否选择各列）。
df[1] # 提取第1列, 同df["id"]

# (2) 以矩阵方式提取数据框的元素、子集
# 以列表形式操作并不支持行选择。以矩阵形式操作更加灵活，同时支持列选择和行选择。即用 [i, j] 指定行或列来提取数据框子集，[ , ]其内可以是数值向量、字符向量或者逻辑向量。
# 若行选择器为空，则只选择列（所有行）：
df[, "level"]
df[, c("level","score")]   # 同df[,2:3]

# 根据条件筛选行或列：
df[df$score >= 0.5, c("id","score")]
ind = names(df) %in% c("level","score")
df[1:2, ind]

## 3.给数据框赋值
## (1) 以列表方式给数据框赋值
## 用$或[[ ]]对数据框的1列赋值:
df$score <- c(0.6,0.3,0.2,0.4) # 同df[["score"]] = c(0.6,0.3,0.2,0.4)

##利用现有列，创建（计算）新列：
df$sum = df$level + df$score
df
df$sum = as.character(df$sum)   # 转换列的类型
df

##用[]可以对数据框的1列或多列进行赋值：
df["score"] <- c(0.8,0.5,0.2,0.4)
df[c("level", "score")] <-  list(c(1,2,1,0), c(0.1,0.2,0.3,0.4))
df

## (2) 以矩阵方式给数据框赋值
df[1:3,"score"] <- c(-1,0,1) #这个时候不会有循环 第四个数据不变
df[1:2,c("level","score")] <- list(c(0,0),c(0.9,1.0))
df

## 4. 一些有用函数
# str()或glimpse()作用在R对象上，显示该对象的结构：
str(persons)
# summary()作用在数据框/列表上，将生成各列/成分的汇总信息：
summary(persons)

# 经常需要将多个数据框（或矩阵）按行或按列进行合并：
# rbind()，增加行（样本数据），要求宽度（列数）相同；
# cbind()，增加列（属性变量），要求高度（行数）相同。
# 向persons数据框中添加一个人的新记录：
rbind(
  persons,
  tibble(
    Name="John",
    Gender="23",
    Age=25,
    Major="Statistics"
        )
)

# 向persons数据框中添加两个新列表示每个人是否已注册和其手头的项目数量：
cbind(persons, Registered = c(TRUE, TRUE, FALSE), Projects = c(3, 2, 3))
#注：更建议用dplyr包提供的bind_rows(), bind_cols().

# expand.grid()可生成多个属性水平值所有组合（笛卡儿积）的数据框：
expand.grid(type = c("A","B"), class = c("M","L","XL"))



